# Java 面试题 #
## java 基础 ##


- **为什么重写equals要重写hashcode方法**？
	
> 重写hashcode方法是为了满足当两个对象的equals方法相等时，其hashcode方法也必然相等这一约定。重写equals方法用于比较的字段，在hashcode方法中也应该有体现。[https://www.cnblogs.com/ouym/p/8963219.html](https://www.cnblogs.com/ouym/p/8963219.html "hashcode&equals")



- **说一下map的分类和常见的情况**
> map接口下总共有4个实现类：HashMap，HashTable，LinkedHashMap和TreeMap。map集合用于存储键值对，通过键获取值。HashMap是最常用的map，是一种基于数组和链表的实现形式。当然在JDK8之后引入了红黑树。由于HashMap是线程不安全的，在并发环境可能会出现线程安全问题。因而JDK提供了HashTable，其是线程安全的，同时HashTable不支持键值的null，但是HashMap支持。由于HashTable是线程安全的，其在同步时的开销也是巨大的。对此，从JDK1.5之后，提供了ConcurrentHashMap，用于并发编程下的map集合。其利用分段加锁的机制，使得同步的开销降低。TreeMap是一种排序的集合，基于键值的排序，因此若键是对象类型，则需要实现comparable接口。其底层为红黑树。


- **对象若不重写hashCode()的话，hashCode()如何计算出来的？**
> hashcode方法直接返回对象的内存地址





- **==比较的是什么?**
> 若不重写equals方法，比较的对象的地址，重写equals的话，按照equals方法比较的内容比较。

- **java8新特性**
> Lambda表达式，流式处理，新的时间api

- **什么是值传递和引用传递**
> 值传递：传递的实际参数的一个副本，这个参数可能是基本类型的值，也可能是引用对象的地址

>引用传递：传递的是引用变量的地址的副本。在java中只存在值传递。

- **&和&&的区别**
> 都表示逻辑与，不同在于&&支持短路功能，即若第一个表示为false则第二个表达式不会再去判断。

## 并发编程 ##

- **介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？**
> Syncronized用来实现线程安全的原子性和可见性，是在jvm层面的对线程安全的一种处理。被Syncronized修饰的方法或代码块在同一时间只允许一个线程访问，只有线程释放锁，另一个线程得到锁才能访问。

> 修饰静态方法，锁的是这个当前类的所有对象；修饰成员方法，锁住的是当前对象。

- **介绍一下volatile**
> volatile可以用来保证线程安全中的可见性和有序性。可见性是指，某一线程对volatile修饰的变量的操作对其他线程是可见的。在这里，volatile修饰的变量，会强制被写入到主内存中去，而不是在工作内存中；同时读的时候也是强制从主内存中读取，保证不同线程所获的是同一个变量值。实现原理主要是通过内存屏障实现（读：store；写：load）。

> 有序性是针对程序运行时的指令重排序。举个例子，在new一个java对象时，经历了三个过程：
1. 为对象分配内存；
2. 将对象进行相应的初始化；
3. 将分配的内存指向当前对象。但是上述的第2步和第3步可能会出现指令重排序，这样当另一个线程在第2步就可能拿到内存中的对象，但是时没有初始化的。在使用的时候就会存在问题。

- **Synchronized和lock**
>
1. synchronized和lock都是互斥锁和重量级锁。都用于线程间的同步。
2. synchronized时基于JVM层面的锁，也就是锁的释放不用程序员关心。交由JVM管理。而Lock是基于JDK层面的锁，锁的释放必须在finally块中释放。
3. Lock支持公平锁，也就是支持最先等待的最先获得锁。在构造方法中声明。
4. Lock支持锁的可中断，也就是可以指定等待时间，如果没有获得锁，就不再等待。降低同步的开销。
5. Lock支持有条件的获得和释放锁，利用Condition手动完成线程之间的同步。


- **AQS**
> AQS,也就是同步队列，是JUC下很重要的一个组件，它提供了很多我们平时在并发编程中的常用组件。AQS内部维护了一个FIFO的双端链表，也就是队列。同时内部拥有一个state的字段用来表示当前共享资源被锁定的状态。当state为0时，表示当前资源没有被锁定，线程可以获取。如果等于1，表示资源被锁定，没有获得锁的线程将会被放在队列尾部等待。而队列头部表示获得当前锁的线程，当其释放锁的时候会通知其后继节点该锁已经释放，可以获取。当同一个线程重入获取锁的时候，state就会加1。


## 数据库 ##

- **数据库的索引**
> 数据库的索引主要有hash和b树两种结构，hash索引主要是利用散列表，比较适合等值查询。而更被广泛应用的是b树索引。数据库的索引主要是B+树，相比于传统的b树，B+树的数据全部存储在叶子节点，非叶子节点只储存指向子节点的指针，这样可以大大减少存储空间；同时所有数据存储在叶子节点意味着每次查询数据的时候从根节点到叶子节点的路径长度差不多，查询更加稳定；最为重要的是，叶子节点之间也维护者指向下一个叶子节点的指针，意味着范围查询更加容易。

- **数据库的事务特性**


> ACID：原子性，持久性，一致性和隔离性。

> 原子性：事务要么全部成功，要么全部失败；
> 
> 持久性：事务的提交对数据改变时持久化的；
> 
> 一致性：事务在提交前后数据的数据一致的，也就是数据库从一个一致性状态转换到另一个一致性状态；
> 
> 隔离性：一个事务不能被其他事务所干扰。


- **数据库的事务特性是如何实现的**

> 事务的特性主要靠redo log，undo log以及MVCC控制的。其中 redo log主要用来实现持久性和一致性，数据库中对数据的更改并不会立即是写入磁盘中，而是先写入到redo log中，在写入redo log过程中，会先写入到log的缓冲区当中。在每次事务提交之前，确保redo log缓冲区的log都持久化到redo log之中。这样如果数据库突然崩溃，则下次数据库启动时就是从redo log中恢复数据，当然只会恢复到上次事务提交的状态。而原子性和隔离性主要靠undo log和MVCC控制。undo log是为了保证数据库事务的原子性的，每次对数据库的修改操作之前，数据库会将原先的数据备份到undo log之中，这样当数据需要回滚时，从undo log回滚即可。MVCC叫多版本并发控制，实际上是乐观锁的一种体现，当一个事务拿到一行数据锁的时候，先把原始数据复制一份到undo log，这样其他事务在执行只读操作时，无需同步。[https://www.cnblogs.com/davygeek/p/7995072.html](https://www.cnblogs.com/davygeek/p/7995072.html "数据库的事务实现")

## JavaWeb ##
- **servlet的生命周期**
> 首先调用servlet的init()方法，完成初始化，然后调用service()方法，执行相关请求并返回响应；最后调用destroy()方法执行servlet的销毁。

- **PrepareStatement的原理和用法**
> 相较于Statement，PrepareStatement利用占位符和方法调用为sql中的动态变量实现赋值，使得代码阅读更加清晰；同时，PrepareStatement支持sql的预编译，也就是下一次如果再次执行相同的语句，无需再编译，只需要将相应的参数替换即可；最后，PrepareStatement可以有效防止sql注入，由于采用了预编译的形式，下一次的无论如 or'1=1'这样的语句和时数据都会被认为是参数，从而不会产生sql注入。





## 项目相关 ##
- **项目简介**
> 首先是两个项目比较相近，所以我就放在一起介绍了。项目是开发的一个商品管理后台，在后台中，卖家可以查看自家商品的出售情况和是同情况，商品的基本架构是基于Spring，SpringMVC和Mybatis的架构。本人主要负责整个项目的开发。首先，负责了整个系统框架的搭建，包括maven的相关依赖以及相关xml配置文件的编写；其次，负责了登录认证和权限认证系统的开发。登录认证就是系统登录功能，权限认证是相应的请求主体是否有权限获得该请求的正确返回值。这部分的功能主要是利用shiro框架实现的。用户的登录和权限信息维护在数据库中，通过shiro框架的realm组件完成与数据库的交互，获得权限和登录信息。数据库维护了四张表，用户表，角色表，权限表，用户--角色表和角色--权限表；第三个任务是对经常查询和开销比较大的查询添加缓存。数据库的IO是影响数据库查询性能最重要的因素，因此降低IO开销对于优化查询性能有重要作用，这其中，缓存就可以提供很重要的帮助。这个系统利用的是redis用作缓存，redis是基于内存的nosql的数据库，基于内存意味者redis的存取很快，官方标准是10wQPS。同时redis也支持数据的持久化，意味着下次开机前可以自动将数据加载到内存中。大大优化查询速度。最后就是文件上传业务的开发，利用linux和ftp协议搭建的图片服务器，客户端利用ftpclient+springMVC相关工具包编写文件上传工具类完成文件的上传。
> 而第二个项目中的重要负责修改前端页面，同时编写基本响应类。只要包括响应代码，响应信息，以及传输到前端的数据。是以JSON格式传输到前端处理的。还有负责就是一些编写sql语句和基本的业务逻辑完成数据库的增删改查操作。以及调用相关api如百度地图api完成发送验证码及其他业务功能。

- **shiro登录认证的介绍**
> shiro是apache旗下的一款用于登录和权限认证的开源框架，框架主要包含四大部分，authenticator, authorizer，session管理以及一个加密模块。其安全管理模块主要利用一个SecurityManager组件管理，管理登录认证，权限认证，session，cache，realm等。登录认证就是平时的登录功能，必须是登陆之后才能查看相关网页，权限认证针对的是越权现象，比如只有管理员才能删除商品，普通用户不行，这时就需要判断当前用户是否有管理员权限。具体操作时在web.xml中配置shiro的过滤器，则在每次请求前提交给shiro框架过滤以下，首先判断当前请求的url是否需要登录，如果需要登录而没有登录，则会跳转到登录页面，登录才能正常访问；其次判断当前登录的用户，在shiro中称为subject是否有权限访问该url如果没有，则进行相关逻辑处理，最简单就是跳转到一个指定的403页面。有访问权限才会访问。shiro不会维护登录认证和权限的相关信息，这些信息都是开发者在数据库维护的，因此框架与数据库利用realm组件，其实就是平时mvc架构的Dao层完成与数据库的交互。


- **shiro会话和缓存管理的介绍**
>shiro提供了一套完整的会话管理机制，使得会话管理不必完全依赖与相关的容器，如servlet等。这里的session不仅仅时web session，也可以是其他的session，当然针对web应用，session完全支持servlet相关的规范。可以有效支持。这样的优点在于比如在EJB服务器和一台servlet服务器构成集群，利用shiro管理session，可以完成注入分布式session的架构。本系统中利用shiro和redis构建的shiro的session管理方案。而缓存管理指的是shiro提供了cacheManager，主要还是降低数据库的查询开销，将查询到的相关登录权限认证信息存在cache中，下次就不用去数据库查找。提高系统性能。本系统中这个cache也是利用redis实现的。


- **redis介绍**
> redis是基于内存的nosql的数据库，其基于内存，意味着存取速度很快，官方标准是10wQPS。同时支持数据持久化，意味着下次开机前数据会加载到内存中。redis的持久化方案主要有RDB和AOF两种方式，RDB是以快照的方式，每隔一段时间，当然这个时间是我们可以设置的，将数据持久话一次，优点是性能比较高，同时持久化文件不会太大，缺点是宕机后可能会丢失一部分数据。而AOF方案是每次将对redis的更新操作以日志方式追加到文件末尾，优点是数据安全性比较高，缺点是随机操作越来越多，备份文件会越来越大。redis中支持string，list，sorted list，hash， set等丰富的数据结构，本系统中主要用的是hash结构，每个商家对应一个hash表，在这个hash表维护相关的键。redis除了用于缓存之外，还被广泛应用于现代的互联网系统架构中，比如，分布式事务，分布式锁。微博等社交网站的排行榜等，请求队列等。

- **redis和数据库的同步**
> 本系统中主要是采用在数据库中设置一个相当于标志位的标志。每次对数据库的更新操作都会更新这个标志位，每次读也会去数据库读这个标志位，如果标志位和redis的值不同，则意味着数据库已经被更改，需要去数据库中读取。之后同步到缓存中。后来觉得这种方式也存在缺点，因为每次都需要你去数据库查询这个标志位。所以大致想了以下三种方案，第一个就是采用异步队列的方式，每次读，依然是那个逻辑，也就是缓存有，从缓存中读，缓存没有，则读数据库。写的话，写入数据库，则采用异步的方式更新到redis中，也就是采用异步的方式维护数据库和redis的一致性。这个方案的弊端就是对于强一致性要求高的系统，如银行金融等不适用。第二种方案就是换个想法，也就是把redis当作db，也就是数据库当作备份，每次读写直接操作的都是redis，然后再采用异步的方式把数据写到数据库中，也就是数据库相当于一个备份。这个方案也有弊端，也就是违反了内存型数据库的初衷，成本很高，毕竟内存价格比硬盘的价格贵的多，同时数据太多时redis的启动加载也会有很大开销。第三种就是利用阿里的canel框架完成数据库和redis的同步，这里面主要利用mysql的日志完成同步。


- **项目中遇到的难题和解决方案**
> **redis和数据库的同步问题**

> 本系统中主要是采用在数据库中设置一个相当于标志位的标志。每次对数据库的更新操作都会更新这个标志位，每次读也会去数据库读这个标志位，如果标志位和redis的值不同，则意味着数据库已经被更改，需要去数据库中读取。之后同步到缓存中。后来觉得这种方式也存在缺点，因为每次都需要你去数据库查询这个标志位。所以大致想了以下三种方案，第一个就是采用异步队列的方式，每次读，依然是那个逻辑，也就是缓存有，从缓存中读，缓存没有，则读数据库。写的话，写入数据库，则采用异步的方式更新到redis中，也就是采用异步的方式维护数据库和redis的一致性。这个方案的弊端就是对于强一致性要求高的系统，如银行金融等不适用。第二种方案就是换个想法，也就是把redis当作db，也就是数据库当作备份，每次读写直接操作的都是redis，然后再采用异步的方式把数据写到数据库中，也就是数据库相当于一个备份。这个方案也有弊端，也就是违反了内存型数据库的初衷，成本很高，毕竟内存价格比硬盘的价格贵的多，同时数据太多时redis的启动加载也会有很大开销。第三种就是利用阿里的canel框架完成数据库和redis的同步，这里面主要利用mysql的日志完成同步。

> **控制验证码的发送频率**

> 前后端都得控制，前端控制按钮在指定时间间隔中不允许点击。后端每次发送验证码时会把验证码放在数据库中，去查询这个手机号有没有发送过验证码，如果没有直接发送，如果有就会获取前一个验证码的发送时间，和当前时间对比小于指定间隔就不会发送，并返回给前端提示信息，比如操作频率过快等。如果大于时间间隔就会发送验证码。

